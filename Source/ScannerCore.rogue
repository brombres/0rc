module Ox

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.

$include "CompileError.rogue"
$include "ScanTable.rogue"
$include "Token.rogue"
$include "TokenType.rogue"

class ScannerCore [abstract]
  DEFINITIONS
    ip_main = 0
    ip_scan_id_or_keyword = 1
    ip_scan_number = 2
    ip_scan_integer = 3
    ip_scan_string = 4

  PROPERTIES
    _filepath     : String
    _scanner      : Rogue::Scanner
    line          = 1L
    column        = 1L

    tokens        = Token[]
    buffer        = String()
    output        = String()

    start_ip      = 0L
    halt          = false

    _position_stack  = Int[]
    _line_stack      = Int[]
    _column_stack    = Int[]
    _token_pos_stack = Int[]

    # GENERATED PROPERTIES
    ch : Character
    _scan_pattern_0 = ScanPattern( "[ \r\t]*" )
    _scan_pattern_1 = ScanPattern( "{#[^\n]*}" )
    _scan_pattern_2 = ScanPattern( "{[_a-zA-Z][_a-zA-Z0-9]*}" )
    _scan_pattern_3 = ScanPattern( "{[0-9a-fA-F][0-9a-fA-F_]*}" )
    _scan_pattern_4 = ScanPattern( "{[01][01_]*}" )
    _scan_pattern_5 = ScanPattern( "[0-9_]+" )
    _scan_pattern_6 = ScanPattern( "{[0-9][0-9_]*}" )
    _scan_pattern_7 = ScanPattern( "[0-9]" )
    _scan_pattern_8 = ScanPattern( "[0-9_]*" )
    _scan_table_0 = ScanTable("Lv8JKRQuFj0cLR4oICUiKyQvJiosAAD/AS8aAQACAAMABAAFAAYABwElKggACQA=")
    _scan_table_1 = ScanTable("NgADcAhzImMs/wFyDP8BaRD/AW4U/wF0GAEBbBz/AW4gAgD/AWkm/wFuKgMA/wFvMP8BczQEAA==")

  METHODS
    method init( file:File )
      init( file.filepath, Rogue::Scanner(file) )
      line   = 1
      column = 1

    method init( filepath:String, content:String, line=1, column=1 )
      init( filepath, Rogue::Scanner(content).[line=line, column=column] )

    method init( _filepath, _scanner )
      noAction

    method execute( ip:Int )
      _clear_state
      _execute( ip )

    method tokenize( ip=null:Int? )->Token[]
      if (ip) start_ip = ip.value
      _clear_state
      while (_execute(start_ip) or not halt)
        buffer.clear
      endWhile
      _on_output_line # flush any buffered output
      return tokens

    method _add( type:TokenType )
      if (type.attributes & TokenType.ATTRIBUTE_CONTENT)
        tokens.add( _t(type,buffer.cloned) )
      else
        tokens.add( _t(type) )
      endIf
      buffer.clear

    method _clear_state
      tokens = Token[]
      buffer.clear
      output.clear
      halt = false

    method _describe_character( c:Character )->String
      if (c == 10 or c == 13)       return "end of line";
      elseIf (c >= 32 and c != 127) return "'$'" (c)
      else                          return "'$'" (c.to_escaped_ascii)

    method _discard_position
      if (_position_stack.is_empty)
        _throw_syntax_error( "discardPosition without prior savePosition." )
      endIf
      _position_stack.remove_last
      _line_stack.remove_last
      _column_stack.remove_last
      _token_pos_stack.remove_last

    method _is_next( text:String )->Logical
      local location = _scanner.location
      local result = _scanner.consume( text )
      _scanner.location = location
      return result

    method _must_consume( ch:Character )
      if (_scanner.consume(ch)) return
      local message = "Syntax error - expected $, found " (_describe_character(ch))
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _must_consume( st:String )
      if (_scanner.consume(st)) return
      _throw_expected_string_error( "'$'" (st.to_escaped_ascii("'")) )

    method _must_consume( pattern:ScanPattern )
      if (pattern.scan(_scanner)) return
      _throw_expected_string_error( pattern->String )

    method _next_is( text:String )->Logical
      if (not _scanner.has_another(text.count)) return false
      local pos = _scanner.position
      forEach (ch at index in text)
        if (ch != _scanner.data[pos+index]) return false
      endForEach
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output )
      flush
      output.clear

    method _restore_position
      if (_position_stack.is_empty)
        _throw_syntax_error( "restorePosition without prior savePosition." )
      endIf
      _scanner.position = _position_stack.remove_last
      _scanner.line     = _line_stack.remove_last
      _scanner.column   = _column_stack.remove_last
      tokens.discard_from( _token_pos_stack.remove_last )

    method _save_position
      _position_stack.add( _scanner.position )
      _line_stack.add( _scanner.line )
      _column_stack.add( _scanner.column )
      _token_pos_stack.add( tokens.count )

    method _scan( ch:Character )->Logical
      if (not _scanner.consume(ch)) return false
      buffer.print ch
      return true

    method _scan( text:String )->Logical
      if (not _scanner.consume(text)) return false
      buffer.print text
      return true

    method _t( type:TokenType, content=null:String )->Token
      return Token( type, _filepath, _scanner.source, line, column, content )

    method _throw_expected_string_error( st:String )
      local message = "Syntax error - expected $, found " (st)
      if (_scanner.has_another) message += _describe_character(_scanner.peek) + "."
      else                      message += "end of input."
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _throw_syntax_error( message=null:String )
      if (not message)
        local builder = String()
        builder.print "Syntax error - unexpected "
        if (not _scanner.has_another)
          builder.println "end of input."
        else
          builder.[ print(_describe_character(_scanner.peek)), print('.') ]
        endIf
        message = builder
      endIf
      throw CompileError( message, _filepath, _scanner.source, _scanner.line, _scanner.column )

    method _execute( ip:Int )->Logical
      which (ip)
        case ip_main: return r_main
        case ip_scan_id_or_keyword: return r_scan_id_or_keyword
        case ip_scan_number: return r_scan_number
        case ip_scan_integer: return r_scan_integer
        case ip_scan_string: return r_scan_string
        others
          halt = true
          return false
      endWhich

    method r_main->Logical
      _scan_pattern_0.scan(_scanner)
      if (_scan_pattern_1.scan(_scanner))
        return false
      endIf
      if ((not _scanner.has_another))
        halt = true
        return false
      endIf
      line   = _scanner.line
      column = _scanner.column
      if (_scanner.consume('\n'))
        _add( TokenType.EOL )
        return false
      endIf
      if (not r_scan_id_or_keyword) return false
      if (not r_scan_number) return false
      if (not r_scan_string) return false
      _scan_table_0.reset
      contingent
        block n=1
          while (_scanner.has_another(n))
            if (not _scan_table_0.accept(_scanner.peek(n-1)))
              escapeWhile
            endIf
            ++n
          endWhile
          necessary (_scan_table_0.has_product)
          loop (_scan_table_0.match_count) _scanner.read
        endBlock
        which (_scan_table_0.product)
          case 0
            _add( TokenType.SYMBOL_CLOSE_PAREN )
            return false
          case 1
            _add( TokenType.SYMBOL_DOT_SLASH )
            return false
          case 2
            _add( TokenType.SYMBOL_EQUALS )
            return false
          case 3
            _add( TokenType.SYMBOL_MINUS )
            return false
          case 4
            _add( TokenType.SYMBOL_OPEN_PAREN )
            return false
          case 5
            _add( TokenType.SYMBOL_PERCENT )
            return false
          case 6
            _add( TokenType.SYMBOL_PLUS )
            return false
          case 7
            _add( TokenType.SYMBOL_SLASH )
            return false
          case 8
            _add( TokenType.SYMBOL_SLASH_PERCENT )
            return false
          case 9
            _add( TokenType.SYMBOL_STAR )
            return false
          others
            necessary (false)
        endWhich
      endContingent
      _throw_syntax_error
      return false
      return true

    method r_scan_id_or_keyword->Logical
      if ((not _scan_pattern_2.scan(_scanner,buffer)))
        return true
      endIf
      _scan_table_1.reset
      contingent
        necessary (_scan_table_1.accept(forEach in buffer))
        which (_scan_table_1.product)
          case 1
            _add( TokenType.KEYWORD_PRINT )
            return false
          case 2
            _add( TokenType.KEYWORD_PRINTLN )
            return false
          case 3
            _add( TokenType.KEYWORD_SIN )
            return false
          case 4
            _add( TokenType.KEYWORD_COS )
            return false
          others
            necessary (false)
        endWhich
      unsatisfied
        _add( TokenType.IDENTIFIER )
        return false
      endContingent

    method r_scan_number->Logical
      if ((not _scanner.has_another))
        return true
      endIf
      if ((_scan('$') or _scan("0x")))
        if (_scan_pattern_3.scan(_scanner,buffer))
          _add( TokenType.INTEGER )
          return false
        else
          _throw_syntax_error("Hexadecimal digits (0-9/a-f/A-F) expected.")
          return false
        endIf
      elseIf (_scan('%'))
        if (_scan_pattern_4.scan(_scanner,buffer))
          _add( TokenType.INTEGER )
          return false
        else
          _add( TokenType.SYMBOL_PERCENT )
          return false
        endIf
      elseIf (_scan("0b"))
        if (_scan_pattern_4.scan(_scanner,buffer))
          _add( TokenType.INTEGER )
          return false
        else
          _throw_syntax_error("Binary digits (0/1) expected.")
          return false
        endIf
      elseIf (_scan('0'))
        if (_scan_pattern_5.scan(_scanner,buffer))
          _add( TokenType.INTEGER )
          return false
        endIf
        if (_scan('.'))
          if (not r_scan_integer) return false
          _add( TokenType.REAL )
          return false
        endIf
        _add( TokenType.INTEGER )
        return false
      elseIf (_scan_pattern_6.scan(_scanner,buffer))
        if (_scan('.'))
          if (not r_scan_integer) return false
          _add( TokenType.REAL )
          return false
        endIf
        _add( TokenType.INTEGER )
        return false
      elseIf (_scan('.'))
        if (_scan_pattern_6.scan(_scanner,buffer))
          _add( TokenType.REAL )
          return false
        endIf
        if (_scanner.consume('/'))
          _add( TokenType.SYMBOL_DOT_SLASH )
          return false
        endIf
        _throw_syntax_error("Value expected after decimal point.")
        return false
      else
        return true
      endIf
      return true

    method r_scan_integer->Logical
      if ((not _scan_pattern_7.scan(_scanner,buffer)))
        return true
      endIf
      _scan_pattern_8.scan(_scanner,buffer)
      return true

    method r_scan_string->Logical
      if ((not _scanner.consume('"')))
        return true
      endIf
      while ((_scanner.has_another and (not _scanner.next_is('\n'))))
        ch = _scanner.read
        if ((ch=='"'))
          _add( TokenType.STRING )
          return false
        elseIf (((ch=='\\') and _scanner.has_another))
          ch = _scanner.read
        endIf
        buffer.print(ch)
      endWhile
      _throw_syntax_error("Unterminated string.")
      return false
      return true

endClass
