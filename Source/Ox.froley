================================================================================
# Ox.froley
================================================================================

--------------------------------------------------------------------------------
tokens
--------------------------------------------------------------------------------
EOL(end of line)
IDENTIFIER identifier [content]
INTEGER    integer    [content]
REAL       real       [content]
STRING     string     [content]

--------------------------------------------------------------------------------
tokens Symbols
--------------------------------------------------------------------------------
SYMBOL_CLOSE_PAREN   )  [structural]
SYMBOL_DOT_SLASH     ./
SYMBOL_EQUALS        =
SYMBOL_MINUS         -
SYMBOL_OPEN_PAREN    (
SYMBOL_PERCENT       %
SYMBOL_PLUS          +
SYMBOL_SLASH         /
SYMBOL_SLASH_PERCENT /%
SYMBOL_STAR          *

--------------------------------------------------------------------------------
tokens Keywords
--------------------------------------------------------------------------------
KEYWORD_PRINT   print
KEYWORD_PRINTLN println
KEYWORD_SIN     sin
KEYWORD_COS     cos

--------------------------------------------------------------------------------
scanner
--------------------------------------------------------------------------------
- main
  consume [ \r\t]*               # whitespace
  if consume("#" [^\n]*) restart # single-line comment

  if (not hasAnother) halt
  markPosition

  if (consume('\n')) produce EOL

  scan_id_or_keyword
  scan_number
  scan_string

  match
    produceAny Symbols
  endMatch

  syntaxError

- scan_id_or_keyword
  if (not scan([_a-zA-Z][_a-zA-Z0-9]*)) return
  # 'scan' fills 'buffer' with matching characters

  match buffer
    produceAny Keywords
    others
      produce IDENTIFIER
      # Because type IDENTIFER has [content], 'buffer' will be copied
      # as the resulting Token's .content string.
  endMatch

- scan_number
  if (not hasAnother) return

  if (scan('$') or scan("0x"))
    if (scan [0-9a-fA-F][0-9a-fA-F_]*)
      produce INTEGER
    else
      syntaxError "Hexadecimal digits (0-9/a-f/A-F) expected."
    endIf
  elseIf (scan('%'))
    if (scan [01][01_]*)
      produce INTEGER
    else
      produce SYMBOL_PERCENT
    endIf
  elseIf (scan("0b"))
    if (scan [01][01_]*)
      produce INTEGER
    else
      syntaxError "Binary digits (0/1) expected."
    endIf
  elseIf (scan '0')
    if (scan [0-9_]+) produce INTEGER  # octal integer
    if (scan '.')
      scan_integer
      produce REAL   # 0.ddd
    endIf
    produce INTEGER  # literal 0
  elseIf (scan [0-9][0-9_]*)
    if (scan '.')
      scan_integer
      produce REAL
    endIf
    produce INTEGER
  elseIf (scan '.')
    if (scan [0-9][0-9_]*) produce REAL
    if (consume('/')) produce SYMBOL_DOT_SLASH
    syntaxError "Value expected after decimal point."
  else
    return
  endIf

- scan_integer
  if (not scan [0-9]) return
  scan [0-9_]*

- scan_string
  if (not consume('"')) return
  while (hasAnother and not nextIs('\n'))
    ch = read
    if (ch == '"') produce STRING
    elseIf (ch == '\\' and hasAnother) ch = read  # VisitContent backslash escapes
    collect ch
  endWhile
  syntaxError "Unterminated string."

--------------------------------------------------------------------------------
parser
--------------------------------------------------------------------------------
- statements
  consume_eols

  beginList

  while (hasAnother and not nextHasAttribute(structural))
    statement
    consume_eols
  endWhile

  produceList Statements

- statement
  on "print"   arg_list -> Print(args)
  on "println" arg_list -> Println(args):Print
  on '+'  -> StackAdd
  on '-'  -> StackSubtract
  on '*'  -> StackMultiply
  on '/'  -> StackDivide
  on '%'  -> StackMod
  on './' -> StackDivideReal
  expression

- consume_eols
  while (consume(EOL)) noAction

- arg_list
  beginList
    while (hasAnother and not nextIs(EOL) and not nextHasAttribute(structural))
      expression
    endWhile
  produceList Args

- expression
  assign

- assign [rightBinary]
  on '=' -> Assign

- add_subtract [binary]
  on '+' -> Add
  on '-' -> Subtract

- multiply_divide_mod [binary]
  on '*'  -> Multiply
  on '/'  -> Divide
  on './' -> DivideReal
  on '%'  -> Mod

- negate [preUnary]
  on "-" -> Negate

- term
  on '(' expression ')': return
  on IDENTIFIER -> Access(name=content)
  on INTEGER    -> LiteralInteger(value=content):LiteralNumber
  on REAL       -> LiteralReal(value=content):LiteralNumber
  on STRING     -> LiteralString(value=content)
  syntaxError

- additional_nodes
  create LiteralInt( value:Int )
  create LiteralNumber
